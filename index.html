<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Erick Vinicius Justino da Silva">
<title>Práticas da Disciplina de Computação Gráfica</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Práticas da Disciplina de Computação Gráfica</h1>
<div class="details">
<span id="author" class="author">Erick Vinicius Justino da Silva</span><br>
<span id="email" class="email"><a href="mailto:erick.justino.701@ufrn.edu.br">erick.justino.701@ufrn.edu.br</a></span><br>
<span id="revdate">2025-07-15</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="#_prefácio">Prefácio</a></li>
<li><a href="#_compilação_dos_projetos">1. Compilação dos Projetos</a></li>
<li><a href="#_curvas_no_plano">2. Curvas no Plano</a>
<ul class="sectlevel2">
<li><a href="#_splines_nurbs">2.1. Splines NURBS</a></li>
<li><a href="#_influência_do_vetor_de_nós_e_da_ordem_na_forma_das_curvas_nurbs">2.2. Influência do Vetor de Nós e da Ordem na Forma das Curvas NURBS</a></li>
<li><a href="#_diferenças_entre_curvas_bézier_e_nurbs_de_mesma_ordem">2.3. Diferenças entre Curvas Bézier e NURBS de Mesma Ordem</a></li>
</ul>
</li>
<li><a href="#_desenhando_linhas_e_pontos">3. Desenhando Linhas e Pontos</a>
<ul class="sectlevel2">
<li><a href="#_quadrado">3.1. Quadrado</a></li>
<li><a href="#_algoritmo_de_bresenham_para_linhas">3.2. Algoritmo de Bresenham para Linhas</a></li>
<li><a href="#_algoritmo_de_bresenham_para_circunferências">3.3. Algoritmo de Bresenham para Circunferências</a></li>
</ul>
</li>
<li><a href="#_modelagem_de_sólidos">4. Modelagem de Sólidos</a>
<ul class="sectlevel2">
<li><a href="#_super_jato">4.1. Super-Jato</a></li>
<li><a href="#_logo_super_jato">4.2. Logo Super-Jato</a></li>
</ul>
</li>
<li><a href="#_modelos_de_iluminação_e_sombreamento">5. Modelos de Iluminação e Sombreamento</a></li>
<li><a href="#_preenchimento_de_regiões">6. Preenchimento de Regiões</a>
<ul class="sectlevel2">
<li><a href="#_nome_e_sobrenome">6.1. Nome e Sobrenome</a></li>
<li><a href="#_seleção">6.2. Seleção</a></li>
<li><a href="#_seleção_com_buffer">6.3. Seleção com Buffer</a></li>
</ul>
</li>
<li><a href="#_projeções_geométricas">7. Projeções Geométricas</a>
<ul class="sectlevel2">
<li><a href="#_tipos_de_projeções_i">7.1. Tipos de Projeções I</a></li>
<li><a href="#_tipos_de_projeções_ii">7.2. Tipos de Projeções II</a></li>
</ul>
</li>
<li><a href="#_superfícies_no_espaço">8. Superfícies no Espaço</a></li>
<li><a href="#_transformações_geométricas">9. Transformações Geométricas</a>
<ul class="sectlevel2">
<li><a href="#_braço_e_garra">9.1. Braço e Garra</a></li>
<li><a href="#_braço_e_garra_3d">9.2. Braço e Garra 3D</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_prefácio">Prefácio</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este documento detalha as implementações desenvolvidas para a disciplina de Computação Gráfica. Cada seção corresponde a uma prática específica, apresentando o problema, a solução implementada em C com OpenGL e as instruções de compilação.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compilação_dos_projetos">1. Compilação dos Projetos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Todos os projetos foram desenvolvidos e testados no ambiente Windows, utilizando o compilador MinGW (g++). Para facilitar o processo de compilação, foi criado um <code>Makefile</code> padrão, que automatiza a geração dos executáveis.</p>
</div>
<div class="paragraph">
<p>O <code>Makefile</code> a seguir foi utilizado como base para todos os projetos. Ele foi configurado para linkar as bibliotecas necessárias (<code>freeglut</code>, <code>opengl32</code>, <code>glu32</code>) no Windows.</p>
</div>
<div id="makefile_base" class="listingblock">
<div class="title">Listagem 1. Makefile base para compilação no Windows</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="makefile"># Nome do compilador C++ (funciona para .c também)
CC = g++

# Nome do executável que será gerado (SEM a extensão .c)
# Mude apenas esta linha para seus outros projetos.
EXEC = quadrado

# Código fonte principal
SRC = $(EXEC).c

# Flags de compilação (O2 para otimização)
CFLAGS = -O2 -Wall

# Bibliotecas (Libs) necessárias para OpenGL com FreeGLUT no Windows
# opengl32 é a biblioteca principal do Windows, freeglut cuida da janela/contexto.
LIBS = -lfreeglut -lopengl32 -lglu32 -lm

# ----- REGRAS -----

# Regra padrão: o que acontece quando você digita apenas 'make'
all: $(EXEC).exe

# Regra para criar o arquivo .exe a partir do .c
# Ele compila o fonte ($&lt;) e gera o executável ($@)
$(EXEC).exe: $(SRC)
	$(CC) $(CFLAGS) $&lt; -o $@ $(LIBS)
	@echo "Programa '$(EXEC).exe' compilado com sucesso!"

# Regra para limpar a pasta
# Remove o executável e outros arquivos temporários
clean:
	-del /F /Q $(EXEC).exe *.o *~ 2&gt;nul
	@echo "Limpeza concluída."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para compilar qualquer um dos projetos, basta abrir o terminal, navegar até a pasta correspondente e editar o campo Exec no Makefile, inserindo o nome do arquivo .c (sem a extensão) que você deseja compilar. Em seguida, execute o comando make para gerar o executável. Após a compilação, é possível rodar o programa diretamente pelo terminal. Caso queira remover os executáveis gerados, utilize o comando make clean.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_curvas_no_plano">2. Curvas no Plano</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta seção apresenta uma aplicação para visualização e manipulação de curvas NURBS (Non-Uniform Rational B-Splines), um padrão para a modelagem de curvas suaves.</p>
</div>
<div class="sect2">
<h3 id="_splines_nurbs">2.1. Splines NURBS</h3>
<div class="paragraph">
<p>O programa <code>splinesnurbs.c</code> permite que o usuário mova os pontos de controle da curva e alterne entre diferentes tipos de vetores de nós (uniforme, aberto e não-uniforme) para observar seus efeitos na forma da curva.</p>
</div>
<div id="exa_splinesnurbs" class="listingblock">
<div class="title">Listagem 2. splinesnurbs.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;math.h&gt;

// ---- Pontos de Controle ----
GLint nVertices = 6;
GLfloat vertices[6][3] = {
    {-4.0, 0.0, 0.0},
    {-4.0, 4.0, 0.0},
    {4.0, -4.0, 0.0},
    {-4.0, -4.0, 0.0},
    {4.0, 4.0, 0.0},
    {4.0, 0.0, 0.0}};

// ---- Variáveis de Interação e Projeção ----
GLint largura, altura;
GLint mudaCurva = 0;
GLint verticeCorrente = 0;
GLfloat esquerda = -5, direita = +5, fundo = -5, topo = +5, longe = +5, perto = -5;
GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
GLdouble wx, wy, wz;

// ---- Lógica das Curvas NURBS ----
GLUnurbsObj *nurbs_renderer;
GLint nNos = 10; // Para 6 pontos de controle e ordem 4, precisamos de 6+4=10 nós.

// Vetor de Nós Uniforme: nós igualmente espaçados.
// A curva não costuma passar pelos pontos de controle das pontas.
GLfloat knots_uniform[] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};

// Vetor de Nós Uniforme Aberto: O tipo mais comum.
// Repete o primeiro e o último nó. Força a curva a passar pelos pontos inicial e final.
GLfloat knots_open_uniform[] = {0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 3.0, 3.0, 3.0};

// Vetor de Nós Não-Uniforme: Espaçamento irregular.
// Permite maior controle, podendo criar "cantos" ou "puxar" a curva.
GLfloat knots_non_uniform[] = {0.0, 0.0, 0.0, 0.0, 1.5, 1.8, 3.0, 3.0, 3.0, 3.0};

// Ponteiro para o vetor de nós atualmente em uso
GLfloat *current_knots;

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    
    // ---- Desenha a Curva NURBS ----
    glColor3f(1.0, 1.0, 1.0); // Cor da curva: branca
    gluBeginCurve(nurbs_renderer);
    // Usa o ponteiro 'current_knots' para desenhar com o vetor de nós ativo
    gluNurbsCurve(nurbs_renderer, nNos, current_knots, 3, &amp;vertices[0][0], 4, GL_MAP1_VERTEX_3);
    gluEndCurve(nurbs_renderer);

    // ---- Desenha os Pontos e a Poligonal de Controle ----
    glPointSize(5.0);
    // Poligonal (amarela)
    glColor3f(1.0, 1.0, 0.0);
    glBegin(GL_LINE_STRIP);
    for (int i = 0; i &lt; nVertices; i++)
        glVertex3fv(&amp;vertices[i][0]);
    glEnd();
    // Pontos (vermelhos)
    glColor3f(1.0, 0.0, 0.0);
    glBegin(GL_POINTS);
    for (int i = 0; i &lt; nVertices; i++)
        glVertex3fv(&amp;vertices[i][0]);
    glEnd();

    glutSwapBuffers();
}

void init(void)
{
    glClearColor(0.0, 0.0, 0.0, 0.0); // Fundo preto
    nurbs_renderer = gluNewNurbsRenderer();
    gluNurbsProperty(nurbs_renderer, GLU_SAMPLING_TOLERANCE, 5.0);
    // Define o vetor de nós inicial como 'uniforme aberto'
    current_knots = knots_open_uniform;
}

void reshape(int w, int h)
{
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
    glMatrixMode(GL_PROJECTION);
    largura = w;
    altura = h;
    glLoadIdentity();
    glOrtho(esquerda, direita, fundo, topo, perto, longe);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
    case 'u': // Vetor de nós Uniforme
        current_knots = knots_uniform;
        glutPostRedisplay();
        break;
    case 'o': // Vetor de nós Uniforme Aberto (Open)
        current_knots = knots_open_uniform;
        glutPostRedisplay();
        break;
    case 'n': // Vetor de nós Não-uniforme
        current_knots = knots_non_uniform;
        glutPostRedisplay();
        break;
    case 27:
        exit(0);
        break;
    }
}

void proximidade()
{
    double tam = 0, tamin = 32000;
    verticeCorrente = 0;
    for (int i = 0; i &lt; nVertices; i++)
    {
        tam = (wx - vertices[i][0]) * (wx - vertices[i][0]) +
              (wy - vertices[i][1]) * (wy - vertices[i][1]);
        if (tam &lt; tamin)
        {
            tamin = tam;
            verticeCorrente = i;
        }
    }
    tamin = sqrt(tamin);
    if (tamin &gt; 0.5)
    {
        mudaCurva = 0;
    }
}

void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) {
            glGetIntegerv(GL_VIEWPORT, matrizViewport);
            glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
            glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);
            int yreal = matrizViewport[3] - (GLint)y - 1;
            gluUnProject((GLdouble)x, (GLdouble)yreal, 0.0,
                         matrizModelview, matrizProjecao, matrizViewport,
                         &amp;wx, &amp;wy, &amp;wz);
            mudaCurva = 1;
            proximidade();
        } else if (state == GLUT_UP) {
            mudaCurva = 0;
        }
    }
}

void motion(int x, int y)
{
    if (mudaCurva)
    {
        int yreal = matrizViewport[3] - (GLint)y - 1;
        gluUnProject((GLdouble)x, (GLdouble)yreal, 0.0,
                     matrizModelview, matrizProjecao, matrizViewport,
                     &amp;wx, &amp;wy, &amp;wz);
        vertices[verticeCorrente][0] = wx;
        vertices[verticeCorrente][1] = wy;
        glutPostRedisplay();
    }
}

int main(int argc, char **argv)
{
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(500, 500);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Tipos de Vetor de Nos em NURBS");
    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutMotionFunc(motion);
    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_influência_do_vetor_de_nós_e_da_ordem_na_forma_das_curvas_nurbs">2.2. Influência do Vetor de Nós e da Ordem na Forma das Curvas NURBS</h3>
<div class="paragraph">
<p>O vetor de nós influencia diretamente como os pontos de controle afetam a curva NURBS. Um vetor uniforme gera uma curva suave, mas que normalmente não passa pelos pontos inicial e final. Já o vetor uniforme aberto, o mais comum, repete os nós nas extremidades, fazendo a curva começar e terminar exatamente nos pontos extremos, o que facilita a modelagem. O vetor não uniforme permite espaçamentos irregulares, oferecendo maior controle local sobre a forma da curva.</p>
</div>
<div class="paragraph">
<p>A ordem da curva também afeta seu comportamento: curvas de ordem mais baixa (como a quadrática) são menos suaves e mais próximas dos pontos de controle. Curvas de ordem mais alta (como a quártica) são mais suaves e soltas, pois cada ponto de controle influencia um trecho maior da curva.</p>
</div>
</div>
<div class="sect2">
<h3 id="_diferenças_entre_curvas_bézier_e_nurbs_de_mesma_ordem">2.3. Diferenças entre Curvas Bézier e NURBS de Mesma Ordem</h3>
<div class="paragraph">
<p>Ao comparar curvas de Bèzier e NURBS de ordens iguais, a principal diferença é o tipo de controle. Bèzier possui controle global, onde mover um ponto afeta toda a extensão da curva. NURBS oferece controle local, permitindo modificar uma parte da curva sem alterar o resto, o que é uma vantagem imensa para designs complexos. Além disso, NURBS são matematicamente superiores por serem "racionais", o que lhes permite representar perfeitamente formas como círculos, algo que as curvas de Bèzier não conseguem fazer. Na prática, uma curva de Bèzier é apenas um caso especial e mais simples de uma curva NURBS.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_desenhando_linhas_e_pontos">3. Desenhando Linhas e Pontos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta seção aborda algoritmos fundamentais para a rasterização de primitivas gráficas, como pontos, linhas e circunferências.</p>
</div>
<div class="sect2">
<h3 id="_quadrado">3.1. Quadrado</h3>
<div class="paragraph">
<p>O primeiro programa (<code>quadrado.c</code>) renderiza um quadrado simples na tela, utilizando funções básicas do OpenGL para desenhar linhas e pontos.</p>
</div>
<div id="exa_quadrado" class="listingblock">
<div class="title">Listagem 3. quadrado.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

// Variável global para controlar a cor do quadrado
// 0 para vermelho, 1 para azul
int corQuadrado = 0; 

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256); 
  glutInitWindowPosition (100, 100); 
  glutCreateWindow ("Desenhando um Quadrado");
  init();
  glutDisplayFunc(display); 
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void){
  // Define o fundo da janela como branco
  glClearColor(1.0, 1.0, 1.0, 1.0); 
  // Define o sistema de coordenadas ortográfico
  // (0,0) é o canto inferior esquerdo e (256,256) é o canto superior direito
  glOrtho (0, 256, 0, 256, -1 ,1);
}

void display(void){
  glClear(GL_COLOR_BUFFER_BIT);

  // Define a cor do quadrado com base na variável corQuadrado
  if (corQuadrado == 0) { // Vermelho
    glColor3f (1.0, 0.0, 0.0); 
  } else { // Azul
    glColor3f (0.0, 0.0, 1.0); 
  }
  
  // Desenha o quadrado usando GL_QUADS
  glBegin(GL_QUADS);
  // Vértice superior esquerdo: (30, 226)
  glVertex2i(30, 226); 
  // Vértice superior direito: (226, 226)
  glVertex2i(226, 226); 
  // Vértice inferior direito: (226, 30)
  glVertex2i(226, 30); 
  // Vértice inferior esquerdo: (30, 30)
  glVertex2i(30, 30); 
  glEnd();

  glFlush();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 'a': // Se 'a' for pressionado, muda para azul
      corQuadrado = 1;
      glutPostRedisplay(); // Redesenha a janela
      break;
    case 'v': // Se 'v' for pressionado, muda para vermelho
      corQuadrado = 0;
      glutPostRedisplay(); // Redesenha a janela
      break;
    case 27: // Tecla ESC para sair
      exit(0);
      break;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmo_de_bresenham_para_linhas">3.2. Algoritmo de Bresenham para Linhas</h3>
<div class="paragraph">
<p>Este programa (<code>Bresenham_linhas.c</code>) implementa o algoritmo de Bresenham para desenhar linhas.</p>
</div>
<div id="exa_bresenham_linhas" class="listingblock">
<div class="title">Listagem 4. Bresenham_linhas.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

void init(void);
void display(void);
void bresenham(int x0, int y0, int x1, int y1);

int main(int argc, char** argv){
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Algoritmo de Bresenham"); // Título da janela
    init();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}

void init(void){
    // Define o fundo da janela como branco
    glClearColor(1.0, 1.0, 1.0, 1.0);
    // Define o sistema de coordenadas
    glOrtho(0, 256, 0, 256, -1, 1);
}

/**
 * @brief Implementação generalizada do Algoritmo de Bresenham para traçado de linhas.
 * * @param x0 Coordenada x do ponto inicial.
 * @param y0 Coordenada y do ponto inicial.
 * @param x1 Coordenada x do ponto final.
 * @param y1 Coordenada y do ponto final.
 */
void bresenham(int x0, int y0, int x1, int y1) {
    // Calcula as variações em x e y (sempre positivas)
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    
    // Determina a direção do incremento para x e y (1 para positivo, -1 para negativo)
    int sx = (x0 &lt; x1) ? 1 : -1;
    int sy = (y0 &lt; y1) ? 1 : -1;
    
    // Parâmetro de decisão (erro)
    int err = dx - dy;
    
    while (1) {
        // Desenha o ponto atual
        glVertex2i(x0, y0);
        
        // Se chegamos ao ponto final, paramos o loop
        if (x0 == x1 &amp;&amp; y0 == y1) {
            break;
        }
        
        int e2 = 2 * err;
        
        // Decide se vamos dar um passo em x
        if (e2 &gt; -dy) {
            err -= dy;
            x0 += sx;
        }
        
        // Decide se vamos dar um passo em y
        if (e2 &lt; dx) {
            err += dx;
            y0 += sy;
        }
    }
}

void display(void){
    glClear(GL_COLOR_BUFFER_BIT);

    // Define a cor da linha como verde
    glColor3f(0.0, 1.0, 0.0);
    
    // Inicia o modo de desenho de pontos
    glBegin(GL_POINTS);
        // Chama a função de Bresenham com as coordenadas especificadas
        bresenham(40, 200, 200, 10);
    glEnd();
    
    glFlush();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_algoritmo_de_bresenham_para_circunferências">3.3. Algoritmo de Bresenham para Circunferências</h3>
<div class="paragraph">
<p>De forma análoga ao anterior, este programa (<code>Bresenham_circunferencia.c</code>) implementa o algoritmo de Bresenham para o desenho de circunferências.</p>
</div>
<div id="exa_bresenham_circunferencia" class="listingblock">
<div class="title">Listagem 5. Bresenham_circunferencia.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

void init(void);
void display(void);
void bresenham_circle(int cx, int cy, int r);
void plot_circle_points(int cx, int cy, int x, int y);

int main(int argc, char** argv){
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Algoritmo de Bresenham para Circunferencias");
    init();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}

void init(void){
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glOrtho(0, 256, 0, 256, -1, 1);
}

/**
 * @brief Desenha um ponto (x,y) e seus 7 pontos simétricos na circunferência.
 * @param cx Coordenada x do centro.
 * @param cy Coordenada y do centro.
 * @param x Deslocamento x a partir do centro.
 * @param y Deslocamento y a partir do centro.
 */
void plot_circle_points(int cx, int cy, int x, int y) {
    glVertex2i(cx + x, cy + y);
    glVertex2i(cx - x, cy + y);
    glVertex2i(cx + x, cy - y);
    glVertex2i(cx - x, cy - y);
    glVertex2i(cx + y, cy + x);
    glVertex2i(cx - y, cy + x);
    glVertex2i(cx + y, cy - x);
    glVertex2i(cx - y, cy - x);
}

/**
 * @brief Implementa o Algoritmo de Bresenham (Ponto Médio) para traçado de circunferências.
 * @param cx Coordenada x do centro.
 * @param cy Coordenada y do centro.
 * @param r Raio da circunferência.
 */
void bresenham_circle(int cx, int cy, int r) {
    int x = 0;
    int y = r;
    int p = 3 - 2 * r; // Parâmetro de decisão inicial

    // Desenha os pontos iniciais antes de começar o loop
    plot_circle_points(cx, cy, x, y);

    while (x &lt;= y) {
        x++; // Sempre incrementa x

        // Se p &lt; 0, o ponto médio está dentro da circunferência
        if (p &lt; 0) {
            p = p + 4 * x + 6;
        } 
        // Se p &gt;= 0, o ponto médio está fora ou na circunferência
        else {
            y--; // Decrementa y
            p = p + 4 * (x - y) + 10;
        }
        
        // Desenha os 8 pontos simétricos para a nova posição (x,y)
        plot_circle_points(cx, cy, x, y);
    }
}

void display(void){
    glClear(GL_COLOR_BUFFER_BIT);

    // Define a cor da circunferência como azul
    glColor3f(0.0, 0.0, 1.0);
    
    // Inicia o modo de desenho de pontos
    glBegin(GL_POINTS);
        // Chama a função de Bresenham para a circunferência especificada
        // Centro (128, 128) e raio 50
        bresenham_circle(128, 128, 50);
    glEnd();
    
    glFlush();
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modelagem_de_sólidos">4. Modelagem de Sólidos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_super_jato">4.1. Super-Jato</h3>
<div class="paragraph">
<p>A prática (<code>superjato.c</code>) consiste na modelagem de um objeto complexo, um avião a jato, utilizando as diversas técnicas aprendidas ao longo da disciplina, como desenho de primitivas, transformações e controle de câmera.</p>
</div>
<div id="exa_superjato" class="listingblock">
<div class="title">Listagem 6. superjato.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;

#define PI 3.1415

// Variáveis de estado da câmera e do jato
GLint WIDTH = 800;
GLint HEIGHT = 600;
GLfloat obs[3] = {0.0, 7.0, 0.0};
GLfloat look[3] = {0.0, 3.0, 0.0};
GLfloat tetaxz = 0;
GLfloat raioxz = 12; // Aumentei o raio inicial para uma visão melhor
GLuint jato;

// --- NOVA FUNÇÃO PARA DESENHAR UM MÍSSIL ---
void desenha_missil(void)
{
    GLUquadricObj *quadric;

    // Corpo do míssil (cinza escuro)
    glColor3f(0.4f, 0.4f, 0.4f);
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.15, 0.15, 1.2, 10, 3);

    // Ogiva do míssil (vermelha)
    glColor3f(0.8f, 0.1f, 0.1f);
    glPushMatrix();
    glTranslatef(0, 0, 1.2);
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.15, 0.0, 0.4, 10, 3);
    glPopMatrix();
}

// Função que constrói o jato usando uma Display List
void compoe_jato(void)
{
    GLUquadricObj *quadric;

    GLfloat asa[][3] = {
        {-4.0, 0.0, 0.0},
        {+4.0, 0.0, 0.0},
        {0.0, 0.0, 3.0}};

    GLfloat cauda[][3] = {
        {0.0, 0.0, 0.0},
        {0.0, 2.0, -1.0},
        {0.0, 2.0, 0.0},
        {0.0, 0.0, 2.0}};

    jato = glGenLists(1);
    glNewList(jato, GL_COMPILE);

    // Cor principal do avião
    glColor3f(0.2, 0.4, 0.15); // Verde militar

    /* Asas */
    glBegin(GL_TRIANGLES);
    glVertex3fv(asa[0]);
    glVertex3fv(asa[1]);
    glVertex3fv(asa[2]);
    glEnd();

    /* Corpo */
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);

    /* Nariz */
    quadric = gluNewQuadric();
    glPushMatrix();
    glTranslatef(0, 0, 4);
    gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
    glPopMatrix();

    /* Cauda */
    glBegin(GL_POLYGON);
    glVertex3fv(cauda[0]);
    glVertex3fv(cauda[1]);
    glVertex3fv(cauda[2]);
    glVertex3fv(cauda[3]);
    glEnd();

    /* Cabine do piloto */
    glPushMatrix();
        glTranslatef(0, 0.3, 3.5);
        glPushMatrix();
        glScalef(0.7, 0.7, 2.0);
        quadric = gluNewQuadric();
        glColor4f(0.3, 0.5, 1.0, 0.5); // Azul semitransparente
        gluSphere(quadric, 0.5, 12, 12);
        glPopMatrix();
    glPopMatrix();

    // --- ADIÇÃO DA TURBINA ---
    glPushMatrix();
        // Move para a traseira do corpo do jato
        glTranslatef(0.0, 0.0, -0.25);
        // Carcaça da turbina (cinza escuro)
        glColor3f(0.3f, 0.3f, 0.3f);
        quadric = gluNewQuadric();
        gluCylinder(quadric, 0.6, 0.6, 0.5, 12, 3);
        // Bocal de exaustão (laranja/amarelo para simular fogo)
        glColor3f(1.0f, 0.8f, 0.0f);
        quadric = gluNewQuadric();
        gluDisk(quadric, 0.0, 0.4, 12, 3);
    glPopMatrix();

    // --- ADIÇÃO DOS MÍSSEIS ---
    // Míssil da asa direita
    glPushMatrix();
        glTranslatef(2.0, -0.3, 1.5);
        desenha_missil();
    glPopMatrix();

    // Míssil da asa esquerda
    glPushMatrix();
        glTranslatef(-2.0, -0.3, 1.5);
        desenha_missil();
    glPopMatrix();

    glEndList();
}

void display(void)
{
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glClearColor(0.7, 0.8, 1.0, 1.0); // Fundo azul claro (céu)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();

    // Calcula a posição do observador
    obs[0] = raioxz * cos(2 * PI * tetaxz / 360);
    obs[2] = raioxz * sin(2 * PI * tetaxz / 360);
    gluLookAt(obs[0], obs[1], obs[2], look[0], look[1], look[2], 0.0, 1.0, 0.0);

    // Desenha o chão (sem textura)
    glColor3f(0.4f, 0.6f, 0.2f); // Chão verde
    glBegin(GL_QUADS);
    glVertex3f(-20, 0, 20);
    glVertex3f(20, 0, 20);
    glVertex3f(20, 0, -20);
    glVertex3f(-20, 0, -20);
    glEnd();

    // Desenha o jato
    glPushMatrix();
    glTranslatef(0.0, 4.0, 0.0); // Posição do jato no ar
    glCallList(jato);
    glPopMatrix();

    glPopMatrix();
    glutSwapBuffers();
}

void reshape(int width, int height)
{
    WIDTH = width;
    HEIGHT = height;
    glViewport(0, 0, (GLint)width, (GLint)height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70.0, width / (float)height, 0.1, 40.0);
    glMatrixMode(GL_MODELVIEW);
}

void special(int key, int x, int y)
{
    switch (key)
    {
    case GLUT_KEY_UP:
        obs[1] = obs[1] + 0.5;
        glutPostRedisplay();
        break;
    case GLUT_KEY_DOWN:
        obs[1] = obs[1] - 0.5;
        glutPostRedisplay();
        break;
    case GLUT_KEY_LEFT:
        tetaxz = tetaxz + 2;
        glutPostRedisplay();
        break;
    case GLUT_KEY_RIGHT:
        tetaxz = tetaxz - 2;
        glutPostRedisplay();
        break;
    }
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
    case 27:
        exit(0);
        break;
    case 'r':
        raioxz = raioxz + 1;
        glutPostRedisplay();
        break;
    case 'R':
        raioxz = raioxz - 1;
        if (raioxz == 0)
        {
            raioxz = 1;
        }
        glutPostRedisplay();
        break;
    }
}

void init()
{
    glEnable(GL_DEPTH_TEST);
    compoe_jato();
}

int main(int argc, char **argv)
{
    glutInitWindowPosition(0, 0);
    glutInitWindowSize(WIDTH, HEIGHT);
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE);

    if (!glutCreateWindow("Super Jato"))
    {
        fprintf(stderr, "Error opening a window.\n");
        exit(-1);
    }

    init();

    glutKeyboardFunc(keyboard);
    glutSpecialFunc(special);
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMainLoop();

    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logo_super_jato">4.2. Logo Super-Jato</h3>
<div class="paragraph">
<p>Este programa (<code>logo_superjato.c</code>) renderiza o logo do super-jato com a minha inicial EV.</p>
</div>
<div id="exa_logo_superjato" class="listingblock">
<div class="title">Listagem 7. logo_superjato.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;

#define PI 3.1415

GLint WIDTH = 800;
GLint HEIGHT = 800;
GLfloat obs[3] = {0.0, 7.0, 0.0};
GLfloat look[3] = {0.0, 3.0, 0.0};
GLfloat tetaxz = 0;
GLfloat raioxz = 12;
GLuint jato;
GLuint textura_logo;

// --- Função para carregar a textura IRIS RGB (64x64 RGB raw) ---
void carrega_textura_logo(const char *filename)
{
    FILE *file = fopen(filename, "rb");
    if (!file)
    {
        printf("Erro ao abrir o arquivo de textura: %s\n", filename);
        exit(1);
    }

    // Certifique-se que estas dimensões correspondem ao seu arquivo logo.rgb
    int width = 30;
    int height = 30;
    int size = width * height * 3;
    GLubyte *data = (GLubyte *)malloc(size);
    fread(data, 1, size, file);
    fclose(file);

    glGenTextures(1, &amp;textura_logo);
    glBindTexture(GL_TEXTURE_2D, textura_logo);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);

    free(data);
}

// --- Função para desenhar um míssil ---
void desenha_missil(void)
{
    GLUquadricObj *quadric;
    glColor3f(0.4f, 0.4f, 0.4f);
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.15, 0.15, 1.2, 10, 3);

    glColor3f(0.8f, 0.1f, 0.1f);
    glPushMatrix();
    glTranslatef(0, 0, 1.2);
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.15, 0.0, 0.4, 10, 3);
    glPopMatrix();
}

// --- Função que compõe o jato ---
void compoe_jato(void)
{
    GLUquadricObj *quadric;
    GLfloat asa[][3] = {
        {-4.0, 0.0, 0.0},
        {+4.0, 0.0, 0.0},
        {0.0, 0.0, 3.0}};

    GLfloat cauda[][3] = {
        {0.0, 0.0, 0.0},
        {0.0, 2.0, -1.0},
        {0.0, 2.0, 0.0},
        {0.0, 0.0, 2.0}};

    jato = glGenLists(1);
    glNewList(jato, GL_COMPILE);

    // Cor base do jato
    glColor3f(0.2, 0.4, 0.15); 

    /* 1. Desenha a asa primeiro */
    glBegin(GL_TRIANGLES);
        glVertex3fv(asa[0]);
        glVertex3fv(asa[1]);
        glVertex3fv(asa[2]);
    glEnd();
    
    
    /* 2. Desenha o logo como "decalque" sobre a asa direita */
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, textura_logo);
    
    // Usar branco para a cor do material faz com que a textura apareça com suas cores originais
    glColor3f(1.0f, 1.0f, 1.0f); 

    // Um pequeno deslocamento em Y para evitar "Z-fighting" (textura "brigando" com o polígono da asa)
    GLfloat y_offset = 0.01f; 

    // ======== CÓDIGO CORRIGIDO PARA O LOGO ========
    // O centro da asa direita está perto de x=1.5, z=1.0.
    // Desenhamos um quad de 1x1 unidade centrado nesse ponto.
    glBegin(GL_QUADS);
        glTexCoord2f(0.0, 0.0); glVertex3f(1.0, y_offset, 0.5); // Canto inferior esquerdo
        glTexCoord2f(1.0, 0.0); glVertex3f(2.0, y_offset, 0.5); // Canto inferior direito
        glTexCoord2f(1.0, 1.0); glVertex3f(2.0, y_offset, 1.5); // Canto superior direito
        glTexCoord2f(0.0, 1.0); glVertex3f(1.0, y_offset, 1.5); // Canto superior esquerdo
    glEnd();
    // ===============================================

    glDisable(GL_TEXTURE_2D);

    // 3. Volta para a cor verde para desenhar o resto do jato
    glColor3f(0.2, 0.4, 0.15); 

    /* Corpo */
    quadric = gluNewQuadric();
    gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);

    /* Nariz */
    quadric = gluNewQuadric();
    glPushMatrix();
    glTranslatef(0, 0, 4);
    gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
    glPopMatrix();

    /* Cauda */
    glBegin(GL_POLYGON);
    glVertex3fv(cauda[0]);
    glVertex3fv(cauda[1]);
    glVertex3fv(cauda[2]);
    glVertex3fv(cauda[3]);
    glEnd();

    /* Cabine */
    glPushMatrix();
        glTranslatef(0, 0.3, 3.5);
        glPushMatrix();
        glScalef(0.7, 0.7, 2.0);
        quadric = gluNewQuadric();
        glColor4f(0.3, 0.5, 1.0, 0.5);
        gluSphere(quadric, 0.5, 12, 12);
        glPopMatrix();
    glPopMatrix();

    /* Turbina */
    glPushMatrix();
        glTranslatef(0.0, 0.0, -0.25);
        glColor3f(0.3f, 0.3f, 0.3f);
        quadric = gluNewQuadric();
        gluCylinder(quadric, 0.6, 0.6, 0.5, 12, 3);
        glColor3f(1.0f, 0.8f, 0.0f);
        quadric = gluNewQuadric();
        gluDisk(quadric, 0.0, 0.4, 12, 3);
    glPopMatrix();

    /* Mísseis */
    glPushMatrix();
        glTranslatef(2.0, -0.3, 1.5);
        desenha_missil();
    glPopMatrix();

    glPushMatrix();
        glTranslatef(-2.0, -0.3, 1.5);
        desenha_missil();
    glPopMatrix();

    glEndList();
}

void display(void)
{
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glClearColor(0.7, 0.8, 1.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    obs[0] = raioxz * cos(2 * PI * tetaxz / 360);
    obs[2] = raioxz * sin(2 * PI * tetaxz / 360);
    gluLookAt(obs[0], obs[1], obs[2], look[0], look[1], look[2], 0.0, 1.0, 0.0);

    // Chão
    glColor3f(0.4f, 0.6f, 0.2f);
    glBegin(GL_QUADS);
    glVertex3f(-20, 0, 20);
    glVertex3f(20, 0, 20);
    glVertex3f(20, 0, -20);
    glVertex3f(-20, 0, -20);
    glEnd();

    // Jato
    glPushMatrix();
    glTranslatef(0.0, 4.0, 0.0);
    glCallList(jato);
    glPopMatrix();

    glPopMatrix();
    glutSwapBuffers();
}

void reshape(int width, int height)
{
    WIDTH = width;
    HEIGHT = height;
    glViewport(0, 0, (GLint)width, (GLint)height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70.0, width / (float)height, 0.1, 40.0);
    glMatrixMode(GL_MODELVIEW);
}

void special(int key, int x, int y)
{
    switch (key)
    {
    case GLUT_KEY_UP:    obs[1] += 0.5; break;
    case GLUT_KEY_DOWN:  obs[1] -= 0.5; break;
    case GLUT_KEY_LEFT:  tetaxz += 2; break;
    case GLUT_KEY_RIGHT: tetaxz -= 2; break;
    }
    glutPostRedisplay();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
    case 27: exit(0); break;
    case 'r': raioxz += 1; break;
    case 'R':
        raioxz -= 1;
        if (raioxz &lt;= 0) raioxz = 1;
        break;
    }
    glutPostRedisplay();
}

void init()
{
    glEnable(GL_DEPTH_TEST);
    carrega_textura_logo("logo.rgb"); // &lt;-- Carrega o logotipo
    compoe_jato();
}

int main(int argc, char **argv)
{
    glutInitWindowPosition(0, 0);
    glutInitWindowSize(WIDTH, HEIGHT);
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE);

    if (!glutCreateWindow("Super Jato com Logotipo"))
    {
        fprintf(stderr, "Erro ao abrir janela.\n");
        exit(-1);
    }

    init();
    glutKeyboardFunc(keyboard);
    glutSpecialFunc(special);
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMainLoop();

    return 0;
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modelos_de_iluminação_e_sombreamento">5. Modelos de Iluminação e Sombreamento</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este projeto (<code>iluminacao2.c</code>) explora o modelo de iluminação de Phong, que combina componentes de iluminação ambiente, difusa e especular para criar um sombreamento mais realista nos objetos 3D.</p>
</div>
<div id="exa_iluminacao" class="listingblock">
<div class="title">Listagem 8. iluminacao2.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GL/glut.h&gt;


#define PI 3.1415

GLint WIDTH =320;
GLint HEIGHT=240;

// (As definições de materiais, luzes e posições permanecem as mesmas)
GLfloat plano_difusa[]    = { 0.5, 0.5, 0.0, 1.0 };
GLfloat plano_especular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat plano_brilho[]    = { 50.0 };
GLfloat mat_a_difusa[]    = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_a_especular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_a_brilho[]    = { 50.0 };
GLfloat mat_b_difusa[]    = { 0.7, 0.7, 0.7, 0.5 };
GLfloat mat_b_especular[] = { 1.0, 1.0, 1.0, 0.5 };
GLfloat mat_b_brilho[]    = { 50.0 };
GLfloat posicao_luz0[]    = { 0.0, 10.0, 0.0, 1.0};
GLfloat cor_luz0[]        = { 1.0, 1.0, 1.0, 1.0};
GLfloat cor_luz0_amb[]    = { 0.3, 0.3, 0.3, 1.0};
GLfloat posicao_luz1[]    = { 0.0, 10.0, 5.0, 1.0};
GLfloat cor_luz1[]        = { 0.0, 0.0, 1.0, 1.0};
GLfloat direcao_luz1[]    = { 0.0, -10.0, -5.0, 1.0};
GLint   spot_luz1         = 30;
GLfloat sem_cor[]         = { 0.0, 0.0, 0.0, 1.0};
GLfloat obs[3]={0.0,7.0,0.0};
GLfloat olho[3]={0.0,3.0,0.0};
GLfloat tetaxz=0;
GLfloat raioxz=6;

// Protótipo da nova função de movimento do mouse
void motion(int x, int y);

void reshape(int width, int height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(0,0,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0,width/(float)height,0.1,30.0);
  glMatrixMode(GL_MODELVIEW);
}

void display(void){
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);

  glDepthMask(GL_TRUE);
  glClearColor(1.0,1.0,1.0,1.0);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

  glShadeModel(GL_SMOOTH);
  
  glPushMatrix();

  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],olho[0],olho[1],olho[2],0.0,1.0,0.0);
  
  // A luz ambiente é atualizada aqui a cada quadro
  glLightfv(GL_LIGHT0, GL_AMBIENT, cor_luz0_amb);

  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, plano_difusa);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, plano_especular);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, plano_brilho);
  
  glNormal3f(0,1,0); 
  glBegin(GL_QUADS);
  glVertex3f(-10,0,10); glVertex3f(10,0,10); glVertex3f(10,0,-10); glVertex3f(-10,0,-10);
  glEnd();

  glPushMatrix();
  glTranslatef(posicao_luz0[0],posicao_luz0[1],posicao_luz0[2]);
  glMaterialfv(GL_FRONT, GL_EMISSION, cor_luz0);
  glutSolidSphere(0.3,5,5);
  glPopMatrix();

  glPushMatrix();
  glTranslatef(posicao_luz1[0],posicao_luz1[1],posicao_luz1[2]);
  glMaterialfv(GL_FRONT, GL_EMISSION, cor_luz1);
  glutSolidSphere(0.3,5,5);
  glPopMatrix();

  glMaterialfv(GL_FRONT, GL_EMISSION, sem_cor);

  // Esfera A (traseira, opaca)
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_a_difusa);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_a_especular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_a_brilho);
  glPushMatrix();
  glTranslatef(0.0,3.0,-3.0);
  glutSolidSphere(1.5,30,30);
  glPopMatrix();

  // Esfera B (frontal, com transparência variável)
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_b_difusa);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_b_especular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_b_brilho);
  glTranslatef(0.0,+3.0,+3.0);
  glutSolidSphere(1.5,30,30);

  glPopMatrix();
  glutSwapBuffers();
}

// --- NOVA FUNÇÃO DE MOVIMENTO PASSIVO DO MOUSE ---
void motion(int x, int y){
    // Verifica se a tecla SHIFT está pressionada
    int mod = glutGetModifiers();

    if (mod == GLUT_ACTIVE_SHIFT) {
        // --- MODO: MUDAR LUZ AMBIENTE ---
        // Mapeia a posição Y do mouse (0 a HEIGHT) para um nível de luz (0.0 a 1.0)
        // O Y do mouse é invertido (0 no topo), então subtraímos de HEIGHT
        GLfloat light_level = (GLfloat)(HEIGHT - y) / (GLfloat)HEIGHT;
        // Garante que o valor fique entre 0.0 e 1.0
        if (light_level &lt; 0.0) light_level = 0.0;
        if (light_level &gt; 1.0) light_level = 1.0;

        printf("Nivel de Luz Ambiente: %.2f\n", light_level);
        // Atualiza os componentes R, G e B da luz ambiente
        cor_luz0_amb[0] = light_level;
        cor_luz0_amb[1] = light_level;
        cor_luz0_amb[2] = light_level;

    } else {
        // --- MODO: MUDAR TRANSPARÊNCIA ---
        // Mapeia a posição X do mouse (0 a WIDTH) para um valor alpha (0.0 a 1.0)
        GLfloat alpha = (GLfloat)x / (GLfloat)WIDTH;
        // Garante que o valor fique entre 0.0 e 1.0
        if (alpha &lt; 0.0) alpha = 0.0;
        if (alpha &gt; 1.0) alpha = 1.0;

        printf("Nivel de Alpha (Transparencia): %.2f\n", alpha);
        // Atualiza o 4º componente (alpha) do material B
        mat_b_difusa[3] = alpha;
        mat_b_especular[3] = alpha;
    }

    // Solicita que a janela seja redesenhada para aplicar as mudanças
    glutPostRedisplay();
}

void special(int key, int x, int y){
  switch (key) {
  case GLUT_KEY_UP:    obs[1]=obs[1]+1; glutPostRedisplay(); break;
  case GLUT_KEY_DOWN:  obs[1] =obs[1]-1; glutPostRedisplay(); break;
  case GLUT_KEY_LEFT:  tetaxz=tetaxz+2; glutPostRedisplay(); break;
  case GLUT_KEY_RIGHT: tetaxz=tetaxz-2; glutPostRedisplay(); break;
  }
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27: exit(0); break;
  case 'r': raioxz=raioxz+1; glutPostRedisplay(); break;
  case 'R': if(raioxz&gt;1) { raioxz=raioxz-1; glutPostRedisplay(); } break;
  }
}

void init(){
  glEnable(GL_DEPTH_TEST);
  // Habilita o blending (necessário para transparência)
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

  glLightfv(GL_LIGHT0, GL_DIFFUSE, cor_luz0);
  glLightfv(GL_LIGHT0, GL_SPECULAR, cor_luz0);
  glLightfv(GL_LIGHT0, GL_AMBIENT, cor_luz0_amb);
  glLightfv(GL_LIGHT0, GL_POSITION, posicao_luz0);

  glLightfv(GL_LIGHT1, GL_DIFFUSE, cor_luz1);
  glLightfv(GL_LIGHT1, GL_SPECULAR, cor_luz1);
  glLightf (GL_LIGHT1, GL_SPOT_CUTOFF, spot_luz1);
  glLightfv(GL_LIGHT1, GL_POSITION, posicao_luz1);
  glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, direcao_luz1);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);

  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);
}

int main(int argc,char **argv){
  glutInitWindowPosition(0,0);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGB|GLUT_DEPTH|GLUT_DOUBLE);

  if(!glutCreateWindow("Iluminacao Interativa 2")) {
    fprintf(stderr,"Error opening a window.\n");
    exit(-1);
  }

  init();
  
  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  // ---- NOVO: Registra a função de movimento passivo do mouse ----
  glutPassiveMotionFunc(motion);
  
  glutMainLoop();
  return(0);
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_preenchimento_de_regiões">6. Preenchimento de Regiões</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta seção aborda técnicas para preenchimento de polígonos e seleção de objetos.</p>
</div>
<div class="sect2">
<h3 id="_nome_e_sobrenome">6.1. Nome e Sobrenome</h3>
<div class="paragraph">
<p>O programa <code>nome_sobrenome.c</code> implementa o algoritmo de preenchimento de polígonos conhecido como Scan-Line para renderizar as iniciais do meu nome e sobrenome (EV).</p>
</div>
<div id="exa_nome_sobrenome" class="listingblock">
<div class="title">Listagem 9. nome_sobrenome.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // Necessário para memset
#include &lt;math.h&gt;

#define PI 3.14159265358979323846

// Array que receberá o padrão no formato correto do OpenGL
GLubyte ev_pattern[128];

// Matriz 32x32 onde 1 = pixel aceso, 0 = pixel apagado.
// Este é o nosso "gabarito" visual, exatamente como deve aparecer.
char visual_pattern[32][32] = {
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
    {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
};

// Função que converte o desenho para o formato do OpenGL, agora com a lógica de bits corrigida
void create_stipple_pattern(const char visual[32][32], GLubyte stipple[128]) {
    memset(stipple, 0, 128);

    for (int r = 0; r &lt; 32; r++) { 
        for (int c = 0; c &lt; 32; c++) { 
            if (visual[r][c] == 1) {
                int stipple_row = 31 - r;
                int byte_index = stipple_row * 4 + (c / 8);
                
                // --- CORREÇÃO FINAL: Inverte a ordem dos bits dentro do byte ---
                // O pixel da esquerda (coluna 0 de um byte) corresponde ao bit mais significativo (bit 7).
                int bit_index_visual = c % 8;
                int bit_index_opengl = 7 - bit_index_visual;
                // -------------------------------------------------------------
                
                stipple[byte_index] |= (1 &lt;&lt; bit_index_opengl);
            }
        }
    }
}


void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0); // Fundo branco
    glOrtho(0, 300, 0, 300, -1, 1);
    create_stipple_pattern(visual_pattern, ev_pattern);
}

void drawHexagon(float cx, float cy, float radius) {
    glBegin(GL_POLYGON);
    for (int i = 0; i &lt; 6; ++i) {
        float angle = (PI / 3.0f * i) + (PI / 6.0f);
        float x = cx + radius * cos(angle);
        float y = cy + radius * sin(angle);
        glVertex2f(x, y);
    }
    glEnd();
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.0, 0.0, 1.0); // Azul

    glEnable(GL_POLYGON_STIPPLE);
    glPolygonStipple(ev_pattern);

    drawHexagon(150, 150, 100); 

    glDisable(GL_POLYGON_STIPPLE);

    glFlush();
}

void keyboard(unsigned char key, int x, int y) {
    if (key == 27) exit(0);
}

int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(300, 300);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Hexagono com EV");
    init();
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seleção">6.2. Seleção</h3>
<div class="paragraph">
<p>O programa <code>selecao.c</code> implementa uma técnica de seleção de objetos (picking) usando o modo <code>GL_SELECT</code> do OpenGL. Isso permite que o usuário identifique e interaja com os quadrados da cena clicando sobre eles.</p>
</div>
<div id="exa_selecao" class="listingblock">
<div class="title">Listagem 10. selecao.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

typedef enum {
    MODE_FILL,
    MODE_BORDER
} EditMode;

typedef struct {
    GLfloat fill_r, fill_g, fill_b;
    GLfloat border_r, border_g, border_b;
} PolygonState;

PolygonState polygons[4];
EditMode current_mode = MODE_FILL;
const int WINDOW_HEIGHT = 256;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void drawPolygon(int id);

int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Selecao de Poligonos");
    init();
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}

void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glOrtho(0, 256, 0, 256, -1, 1);
    srand(time(NULL));

    for (int i = 0; i &lt; 4; i++) {
        polygons[i].fill_r = 1.0f;
        polygons[i].fill_g = 1.0f;
        polygons[i].fill_b = 0.0f;
        polygons[i].border_r = 0.0f;
        polygons[i].border_g = 0.0f;
        polygons[i].border_b = 0.0f;
    }
}

// ---- Função de Desenho (CORRIGIDA) ----
void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);

    for (int i = 0; i &lt; 4; i++) {
        // --- Passada 1: Preenchimento ---
        glEnable(GL_POLYGON_OFFSET_FILL);
        glPolygonOffset(1.0f, 1.0f);
        
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glColor3f(polygons[i].fill_r, polygons[i].fill_g, polygons[i].fill_b);
        drawPolygon(i);
        
        glDisable(GL_POLYGON_OFFSET_FILL);

        // --- Passada 2: Borda ---
        glLineWidth(2.0f);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glColor3f(polygons[i].border_r, polygons[i].border_g, polygons[i].border_b);
        drawPolygon(i);
    }

    glutSwapBuffers();
}

void drawPolygon(int id) {
    glBegin(GL_POLYGON);
    switch (id) {
        case 0: // Superior Esquerdo
            glVertex2i(30, 226);  glVertex2i(113, 226);
            glVertex2i(113, 143); glVertex2i(30, 143);
            break;
        case 1: // Superior Direito
            glVertex2i(143, 226); glVertex2i(226, 226);
            glVertex2i(226, 143); glVertex2i(143, 143);
            break;
        case 2: // Inferior Esquerdo
            glVertex2i(30, 113);  glVertex2i(113, 113);
            glVertex2i(113, 30);  glVertex2i(30, 30);
            break;
        case 3: // Inferior Direito
            glVertex2i(143, 113); glVertex2i(226, 113);
            glVertex2i(226, 30);  glVertex2i(143, 30);
            break;
    }
    glEnd();
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'b': case 'B':
            current_mode = MODE_BORDER;
            printf("Modo: Mudar cor da BORDA\n");
            break;
        case 'f': case 'F':
            current_mode = MODE_FILL;
            printf("Modo: Mudar cor do FUNDO\n");
            break;
        case 27:
            exit(0);
            break;
    }
}

void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {
        int ogl_y = WINDOW_HEIGHT - y;
        int selected_polygon = -1;

        if ((x &gt; 30 &amp;&amp; x &lt; 113) &amp;&amp; (ogl_y &gt; 143 &amp;&amp; ogl_y &lt; 226))   selected_polygon = 0;
        if ((x &gt; 143 &amp;&amp; x &lt; 226) &amp;&amp; (ogl_y &gt; 143 &amp;&amp; ogl_y &lt; 226))  selected_polygon = 1;
        if ((x &gt; 30 &amp;&amp; x &lt; 113) &amp;&amp; (ogl_y &gt; 30 &amp;&amp; ogl_y &lt; 113))    selected_polygon = 2;
        if ((x &gt; 143 &amp;&amp; x &lt; 226) &amp;&amp; (ogl_y &gt; 30 &amp;&amp; ogl_y &lt; 113))   selected_polygon = 3;

        if (selected_polygon != -1) {
            printf("Poligono %d selecionado.\n", selected_polygon);
            GLfloat r = (GLfloat)rand() / RAND_MAX;
            GLfloat g = (GLfloat)rand() / RAND_MAX;
            GLfloat b = (GLfloat)rand() / RAND_MAX;

            if (current_mode == MODE_FILL) {
                polygons[selected_polygon].fill_r = r;
                polygons[selected_polygon].fill_g = g;
                polygons[selected_polygon].fill_b = b;
            } else { // MODE_BORDER
                polygons[selected_polygon].border_r = r;
                polygons[selected_polygon].border_g = g;
                polygons[selected_polygon].border_b = b;
            }
            glutPostRedisplay();
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seleção_com_buffer">6.3. Seleção com Buffer</h3>
<div class="paragraph">
<p>Uma abordagem alternativa para a seleção é implementada em <code>selecao_buffer.c</code>. Esta técnica utiliza um buffer de cor auxiliar.</p>
</div>
<div id="exa_selecao_buffer" class="listingblock">
<div class="title">Listagem 11. selecao_buffer.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

// ... (as structs e variáveis globais permanecem as mesmas) ...
typedef enum { MODE_FILL, MODE_BORDER } EditMode;
typedef struct {
    GLfloat fill_r, fill_g, fill_b;
    GLfloat border_r, border_g, border_b;
} PolygonState;

PolygonState polygons[4];
EditMode current_mode = MODE_FILL;
const int WINDOW_HEIGHT = 256;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void drawPolygon(int id);

int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    // ----- MUDANÇA 1: De GLUT_DOUBLE para GLUT_SINGLE -----
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    // ----------------------------------------------------
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Selecao de Poligonos (Buffer Simples)");
    init();
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}

void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glOrtho(0, 256, 0, 256, -1, 1);
    srand(time(NULL));

    for (int i = 0; i &lt; 4; i++) {
        polygons[i].fill_r = 1.0f;
        polygons[i].fill_g = 1.0f;
        polygons[i].fill_b = 0.0f;
        polygons[i].border_r = 0.0f;
        polygons[i].border_g = 0.0f;
        polygons[i].border_b = 0.0f;
    }
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);

    for (int i = 0; i &lt; 4; i++) {
        glEnable(GL_POLYGON_OFFSET_FILL);
        glPolygonOffset(1.0f, 1.0f);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glColor3f(polygons[i].fill_r, polygons[i].fill_g, polygons[i].fill_b);
        drawPolygon(i);
        glDisable(GL_POLYGON_OFFSET_FILL);

        glLineWidth(2.0f);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glColor3f(polygons[i].border_r, polygons[i].border_g, polygons[i].border_b);
        drawPolygon(i);
    }

    // ----- MUDANÇA 2: De glutSwapBuffers() para glFlush() -----
    glFlush();
    // --------------------------------------------------------
}

// ... (As funções drawPolygon, keyboard, e mouse permanecem exatamente as mesmas) ...
void drawPolygon(int id) {
    glBegin(GL_POLYGON);
    switch (id) {
        case 0: glVertex2i(30, 226);  glVertex2i(113, 226); glVertex2i(113, 143); glVertex2i(30, 143); break;
        case 1: glVertex2i(143, 226); glVertex2i(226, 226); glVertex2i(226, 143); glVertex2i(143, 143); break;
        case 2: glVertex2i(30, 113);  glVertex2i(113, 113); glVertex2i(113, 30);  glVertex2i(30, 30); break;
        case 3: glVertex2i(143, 113); glVertex2i(226, 113); glVertex2i(226, 30);  glVertex2i(143, 30); break;
    }
    glEnd();
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'b': case 'B': current_mode = MODE_BORDER; printf("Modo: Mudar cor da BORDA\n"); break;
        case 'f': case 'F': current_mode = MODE_FILL; printf("Modo: Mudar cor do FUNDO\n"); break;
        case 27: exit(0); break;
    }
}

void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {
        int ogl_y = WINDOW_HEIGHT - y;
        int selected_polygon = -1;
        if ((x &gt; 30 &amp;&amp; x &lt; 113) &amp;&amp; (ogl_y &gt; 143 &amp;&amp; ogl_y &lt; 226))   selected_polygon = 0;
        if ((x &gt; 143 &amp;&amp; x &lt; 226) &amp;&amp; (ogl_y &gt; 143 &amp;&amp; ogl_y &lt; 226))  selected_polygon = 1;
        if ((x &gt; 30 &amp;&amp; x &lt; 113) &amp;&amp; (ogl_y &gt; 30 &amp;&amp; ogl_y &lt; 113))    selected_polygon = 2;
        if ((x &gt; 143 &amp;&amp; x &lt; 226) &amp;&amp; (ogl_y &gt; 30 &amp;&amp; ogl_y &lt; 113))   selected_polygon = 3;
        if (selected_polygon != -1) {
            printf("Poligono %d selecionado.\n", selected_polygon);
            GLfloat r = (GLfloat)rand() / RAND_MAX;
            GLfloat g = (GLfloat)rand() / RAND_MAX;
            GLfloat b = (GLfloat)rand() / RAND_MAX;
            if (current_mode == MODE_FILL) {
                polygons[selected_polygon].fill_r = r;
                polygons[selected_polygon].fill_g = g;
                polygons[selected_polygon].fill_b = b;
            } else {
                polygons[selected_polygon].border_r = r;
                polygons[selected_polygon].border_g = g;
                polygons[selected_polygon].border_b = b;
            }
            glutPostRedisplay();
        }
    }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_projeções_geométricas">7. Projeções Geométricas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Aqui, são explorados diferentes tipos de projeções utilizadas para mapear uma cena 3D em uma imagem 2D.</p>
</div>
<div class="sect2">
<h3 id="_tipos_de_projeções_i">7.1. Tipos de Projeções I</h3>
<div class="paragraph">
<p>O programa <code>tiposdeprojecoes.c</code> demonstra e permite alternar entre projeções perspectiva e ortogonal. O usuário pode observar como a escolha da projeção afeta a percepção de profundidade e a aparência dos objetos na cena.</p>
</div>
<div id="exa_tiposdeprojecoes" class="listingblock">
<div class="title">Listagem 12. tiposdeprojecoes.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Definições de cores
#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     0.0, 1.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

// ---- Variáveis de Estado ----
static int eixoy = 0, eixox = 0;
// Guarda qual visão está ativa (0=Canto, 1=Frente, 2=Traseira, etc.)
static int current_view = 0; 
int largura, altura;

// ---- Dados do Objeto ----
static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */ 20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */ 30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */ 0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */ 30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */ 30.0, 30.0, 30.0  /* 9 */
}; 

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};
    

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE); 
}

// RESHAPE agora cuida apenas da Projeção (a "lente")
void reshape (int w, int h){
  largura = w;
  altura = h;
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 150.0); // Aumentei o zFar
  glMatrixMode (GL_MODELVIEW);
}

// DISPLAY agora cuida da Câmera (Visão) e do desenho do Modelo
void display(void){
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
  
  // Reseta a matriz de Visão/Modelo para o início de cada quadro
  glLoadIdentity();

  // 1. POSICIONA A CÂMERA (Visão)
  switch(current_view) {
    case 1: gluLookAt(15, 15, 80, 15, 15, 15, 0, 1, 0); break; // Frente
    case 2: gluLookAt(15, 15, -50, 15, 15, 15, 0, 1, 0); break; // Traseira
    case 3: gluLookAt(15, 80, 15, 15, 15, 15, 0, 0, -1); break; // Topo
    case 4: gluLookAt(15, -50, 15, 15, 15, 15, 0, 0, 1); break; // Fundo
    case 5: gluLookAt(-50, 15, 15, 15, 15, 15, 0, 1, 0); break; // Esquerda
    case 6: gluLookAt(80, 15, 15, 15, 15, 15, 0, 1, 0); break; // Direita
    case 0: // Canto (default)
    default:
        gluLookAt(50, 40, 60, 15, 15, 15, 0, 1, 0);
        break;
  }

  // 2. APLICA AS ROTAÇÕES MANUAIS NO OBJETO (Modelo)
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  
  // 3. DESENHA O OBJETO
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL);       /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);
  glColor3f (AMARELO);    /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);
  glColor3f (VERMELHO);   /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);
  glColor3f (VERDE);      /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);
  glColor3f (CYAN);       /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);
  glColor3f (LARANJA);    /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);
  glColor3f (CINZA);      /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glutSwapBuffers();
}

// KEYBOARD agora apenas muda o estado das variáveis
void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 27: exit(0); break;
    // Rotações manuais
    case 'y': eixoy = (eixoy + 5) % 360; break;
    case 'Y': eixoy = (eixoy - 5) % 360; break;
    case 'x': eixox = (eixox + 5) % 360; break;
    case 'X': eixox = (eixox - 5) % 360; break;
    // Seleção de visão (apenas muda a variável e reseta a rotação manual)
    case 'F': current_view = 1; eixox = eixoy = 0; break;
    case 'T': current_view = 2; eixox = eixoy = 0; break;
    case 't': current_view = 3; eixox = eixoy = 0; break;
    case 'f': current_view = 4; eixox = eixoy = 0; break;
    case 'e': current_view = 5; eixox = eixoy = 0; break;
    case 'd': current_view = 6; eixox = eixoy = 0; break;
    case 'c': current_view = 0; eixox = eixoy = 0; break;
  }
  glutPostRedisplay();
}


int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GL_DEPTH);
  glutInitWindowSize (400, 400); 
  glutInitWindowPosition (100, 100); 
  glutCreateWindow ("Tipos de Projecoes - Corrigido");
  init();
  glutDisplayFunc(display); 
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_de_projeções_ii">7.2. Tipos de Projeções II</h3>
<div class="paragraph">
<p>A segunda versão (<code>tiposdeprojecoes_2.c</code>) aprofunda o estudo, oferecendo retardos entre as apresentações dos quadros da animação, tornando mais agradável a visualização.</p>
</div>
<div id="exa_tiposdeprojecoes_2" class="listingblock">
<div class="title">Listagem 13. tiposdeprojecoes_2.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; // Necessário para a função usleep()

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);
void idle(void); // Protótipo da nova função de animação

// Definições de cores
#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     0.0, 1.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

// ---- MUDANÇA: Ângulos como GLfloat para animação suave ----
static GLfloat eixoy = 0.0, eixox = 0.0;
int largura, altura;

// (Os dados dos vértices e índices permanecem os mesmos)
static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */ 20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */ 30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */ 0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */ 30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */ 30.0, 30.0, 30.0  /* 9 */
}; 
static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};
    
int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GL_DEPTH);
  glutInitWindowSize (400, 400); 
  glutInitWindowPosition (100, 100); 
  glutCreateWindow ("Animacao com glutIdleFunc");
  init();
  glutDisplayFunc(display); 
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  // ---- NOVO: Registra a função de animação ----
  glutIdleFunc(idle);
  // -------------------------------------------
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE); 
}

void reshape (int w, int h){
  largura = w;
  altura = h;
  glViewport(0, 0, (GLsizei)w, (GLsizei)h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  // Inicia com projeção de perspectiva por padrão
  gluPerspective(65.0, (GLfloat)w / (GLfloat)h, 1.0, 100.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef(0.0, 0.0, -60.0); // Move a câmera um pouco para trás
}

void display(void){
  glPushMatrix();
  glRotatef (eixoy, 0.0, 1.0, 0.0);
  glRotatef (eixox, 1.0, 0.0, 0.0);
  
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
  
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL);       glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);
  glColor3f (AMARELO);    glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);
  glColor3f (VERMELHO);   glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);
  glColor3f (VERDE);      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);
  glColor3f (CYAN);       glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);
  glColor3f (LARANJA);    glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);
  glColor3f (CINZA);      glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();
  glutSwapBuffers();
}

// ---- NOVA FUNÇÃO IDLE ----
void idle(void) {
    // Incrementa os ângulos com valores pequenos e diferentes
    eixox += 0.2f;
    eixoy += 0.3f;

    // Solicita que a cena seja redesenhada
    glutPostRedisplay();

    // Introduz um pequeno atraso em microssegundos (16000 us = 16 ms)
    // para uma animação de aproximadamente 60 quadros por segundo.
    usleep(16000);
}
// -------------------------

// ---- TECLADO SIMPLIFICADO ----
void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 27:
      exit(0);
      break;
    // As teclas de rotação manual foram removidas, pois a animação é automática.
    case 'p': // Projeção de Perspectiva
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 1.0, 100.0);
      glMatrixMode(GL_MODELVIEW);
      glutPostRedisplay();
      break;
    case 'o': // Projeção Ortogonal
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glOrtho (-50, 50, -50, 50, -50 , 50);
      glMatrixMode(GL_MODELVIEW);
      glutPostRedisplay();
      break;
  }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_superfícies_no_espaço">8. Superfícies no Espaço</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este projeto (<code>splineinter.c</code>) foca na interpolação de splines para a criação de superfícies no espaço 3D. A aplicação renderiza uma superfície baseada em um conjunto de pontos de controle, demonstrando técnicas de modelagem de formas complexas.</p>
</div>
<div id="exa_splineinter" class="listingblock">
<div class="title">Listagem 14. splineinter.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

// ---- Variáveis Globais ----
static GLfloat view_rot_x = -30.0f;
static GLfloat view_rot_y = 30.0f;
static int last_x, last_y;
static int current_button = -1;
int is_dragging = 0;
int selected_i = -1, selected_j = -1;
GLdouble selected_winZ;
GLfloat ctrlpoints[4][4][3];
GLUnurbsObj *theNurb;  // Agora é global

// Protótipos
void init(void);
void display(void);
void reshape(int w, int h);
void keyboard(unsigned char key, int x, int y);
void mouse(int button, int state, int x, int y);
void motion(int x, int y);

void init_surface(void) {
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            ctrlpoints[i][j][0] = 2.0 * ((GLfloat)i - 1.5);
            ctrlpoints[i][j][1] = 2.0 * ((GLfloat)j - 1.5);
            ctrlpoints[i][j][2] = 0.0;
        }
    }
}

int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(700, 700);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Modelagem Interativa de Spline (Solucao Definitiva)");
    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMotionFunc(motion);
    glutMainLoop();
    return 0;
}

void init(void) {
    GLfloat light_ambient[] = { 0.2f, 0.2f, 0.2f, 1.0f };
    GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.0f };
    GLfloat light_specular[] = { 0.5f, 0.5f, 0.5f, 1.0f };
    GLfloat light_position[] = { 0.0f, 5.0f, 5.0f, 0.0f };

    GLfloat mat_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};
    GLfloat mat_shininess[] = {100.0f};

    glClearColor(0.1, 0.1, 0.1, 0.0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    init_surface();

    // Cria e configura o NURBS uma vez
    theNurb = gluNewNurbsRenderer();
    gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 25.0);
    gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void) {
    GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glPushMatrix();
    glRotatef(view_rot_x, 1.0, 0.0, 0.0);
    glRotatef(view_rot_y, 0.0, 1.0, 0.0);

    // Desenha a Superfície NURBS
    glColor3f(0.7f, 0.7f, 0.8f);
    gluBeginSurface(theNurb);
    gluNurbsSurface(theNurb, 8, knots, 8, knots, 4 * 3, 3, &amp;ctrlpoints[0][0][0], 4, 4, GL_MAP2_VERTEX_3);
    gluEndSurface(theNurb);
    
    // Desenha a malha e os pontos de controle
    glDisable(GL_LIGHTING);

    glColor3f(1.0, 1.0, 0.0); // Linhas amarelas
    for (int i = 0; i &lt; 4; i++) {
        glBegin(GL_LINE_STRIP);
        for (int j = 0; j &lt; 4; j++) glVertex3fv(&amp;ctrlpoints[i][j][0]);
        glEnd();
    }
    for (int j = 0; j &lt; 4; j++) {
        glBegin(GL_LINE_STRIP);
        for (int i = 0; i &lt; 4; i++) glVertex3fv(&amp;ctrlpoints[i][j][0]);
        glEnd();
    }

    glPointSize(5.0);
    glColor3f(1.0, 0.0, 0.0); // Pontos vermelhos
    glBegin(GL_POINTS);
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) glVertex3fv(&amp;ctrlpoints[i][j][0]);
    }
    glEnd();

    glEnable(GL_LIGHTING);
    
    glPopMatrix();
    glutSwapBuffers();
}

void reshape(int w, int h) {
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (GLdouble)w / (GLdouble)h, 3.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -10.0);
}

void keyboard(unsigned char key, int x, int y) {
    if (key == 27) {
        if (theNurb) gluDeleteNurbsRenderer(theNurb);
        exit(0);
    }
}

void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) {
            is_dragging = 1;
            GLdouble modelview[16], projection[16]; GLint viewport[4];
            glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
            glGetDoublev(GL_PROJECTION_MATRIX, projection);
            glGetIntegerv(GL_VIEWPORT, viewport);
            int ogl_y = viewport[3] - y;
            GLdouble near_x, near_y, near_z, far_x, far_y, far_z;
            gluUnProject(x, ogl_y, 0.0, modelview, projection, viewport, &amp;near_x, &amp;near_y, &amp;near_z);
            gluUnProject(x, ogl_y, 1.0, modelview, projection, viewport, &amp;far_x, &amp;far_y, &amp;far_z);
            GLfloat ray_origin[3] = {(float)near_x, (float)near_y, (float)near_z};
            GLfloat ray_dir[3] = {(float)(far_x - near_x), (float)(far_y - near_y), (float)(far_z - near_z)};
            float min_dist = 9999.0;
            int temp_i = -1, temp_j = -1;
            for (int i = 0; i &lt; 4; i++) {
                for (int j = 0; j &lt; 4; j++) {
                    GLfloat* R = ctrlpoints[i][j];
                    GLfloat R_minus_Po[3] = {R[0] - ray_origin[0], R[1] - ray_origin[1], R[2] - ray_origin[2]};
                    float dot1 = R_minus_Po[0]*ray_dir[0] + R_minus_Po[1]*ray_dir[1] + R_minus_Po[2]*ray_dir[2];
                    float dot2 = ray_dir[0]*ray_dir[0] + ray_dir[1]*ray_dir[1] + ray_dir[2]*ray_dir[2];
                    float t = dot1 / dot2;
                    GLfloat closest_point[3] = {ray_origin[0] + t * ray_dir[0], ray_origin[1] + t * ray_dir[1], ray_origin[2] + t * ray_dir[2]};
                    float dist = sqrt(pow(R[0] - closest_point[0], 2) + pow(R[1] - closest_point[1], 2) + pow(R[2] - closest_point[2], 2));
                    if (dist &lt; min_dist) { min_dist = dist; temp_i = i; temp_j = j; }
                }
            }
            if (min_dist &lt; 0.2) {
                selected_i = temp_i;
                selected_j = temp_j;
                GLdouble winX, winY;
                gluProject(ctrlpoints[selected_i][selected_j][0], ctrlpoints[selected_i][selected_j][1], ctrlpoints[selected_i][selected_j][2],
                           modelview, projection, viewport, &amp;winX, &amp;winY, &amp;selected_winZ);
            } else {
                selected_i = -1; selected_j = -1;
            }
        } else if (state == GLUT_UP) {
            is_dragging = 0;
            selected_i = -1; selected_j = -1;
        }
    } else {
        current_button = button;
        last_x = x;
        last_y = y;
    }
}

void motion(int x, int y) {
    if (is_dragging &amp;&amp; selected_i != -1) {
        GLdouble modelview[16], projection[16]; GLint viewport[4];
        glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
        glGetDoublev(GL_PROJECTION_MATRIX, projection);
        glGetIntegerv(GL_VIEWPORT, viewport);
        int ogl_y = viewport[3] - y;
        GLdouble new_wx, new_wy, new_wz;
        gluUnProject(x, ogl_y, selected_winZ, modelview, projection, viewport, &amp;new_wx, &amp;new_wy, &amp;new_wz);
        ctrlpoints[selected_i][selected_j][0] = new_wx;
        ctrlpoints[selected_i][selected_j][1] = new_wy;
        ctrlpoints[selected_i][selected_j][2] = new_wz;
        glutPostRedisplay();
    } else if (current_button != -1) {
        view_rot_y += (x - last_x);
        view_rot_x += (y - last_y);
        last_x = x; last_y = y;
        glutPostRedisplay();
    }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_transformações_geométricas">9. Transformações Geométricas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nesta seção, são exploradas as transformações geométricas 2D e 3D, utilizando um braço robótico com garra.</p>
</div>
<div class="sect2">
<h3 id="_braço_e_garra">9.1. Braço e Garra</h3>
<div class="paragraph">
<p>O programa <code>braco_garra.c</code> implementa um braço robótico com uma garra. O usuário pode interativamente controlar os movimentos do braço e da garra utilizando o teclado, observando a aplicação de transformações.</p>
</div>
<div id="exa_braco_garra" class="listingblock">
<div class="title">Listagem 15. braco_garra.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

// Variáveis de estado para os ângulos das articulações
static int shoulder = 0, elbow = 0;
static int finger_index = 0, finger_middle = 0, finger_thumb = 0;

// Variáveis de câmera
static GLfloat view_rot_x = 20.0f; 
static GLfloat view_rot_y = -30.0f;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
  glEnable(GL_DEPTH_TEST);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  glPushMatrix(); 
  
  glRotatef(view_rot_x, 1.0, 0.0, 0.0);
  glRotatef(view_rot_y, 0.0, 1.0, 0.0);
  
  // Braço
  glTranslatef (-2.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.6, 1.0);
  glutWireCube (1.0);
  glPopMatrix();
   
  // Antebraço
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.6, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  // Início da Garra
  glTranslatef(1.0, 0.0, 0.0);

  // Dedo Indicador
  glPushMatrix();
      glTranslatef(0.0, 0.2, 0.0);
      glRotatef((GLfloat) finger_index, 0.0, 0.0, 1.0);
      glTranslatef(0.5, 0.0, 0.0);
      glPushMatrix();
          glScalef(1.0, 0.2, 0.2);
          glutWireCube(1.0);
      glPopMatrix();
  glPopMatrix();

  // Dedo Médio
  glPushMatrix();
      glTranslatef(0.0, -0.2, 0.0);
      glRotatef((GLfloat) finger_middle, 0.0, 0.0, 1.0);
      glTranslatef(0.5, 0.0, 0.0);
      glPushMatrix();
          glScalef(1.0, 0.2, 0.2);
          glutWireCube(1.0);
      glPopMatrix();
  glPopMatrix();

  // Dedo Polegar (AJUSTE FINO FINAL)
  glPushMatrix();
      // Move a base do polegar para a SUPERFÍCIE EXATA do antebraço.
      // O valor foi ajustado de 0.55 para 0.5 para remover o espaço.
      glTranslatef(0.0, 0.0, 0.5);

      // Rotaciona para apontar para FRENTE.
      glRotatef(-90.0, 0.0, 1.0, 0.0);

      // Aplica a rotação controlável (p/P).
      glRotatef((GLfloat) finger_thumb, 0.0, 0.0, 1.0);
      
      // Move para o centro do polegar para desenhá-lo.
      glTranslatef(0.4, 0.0, 0.0);
      
      glPushMatrix();
          glScalef(0.8, 0.2, 0.2);
          glutWireCube(1.0);
      glPopMatrix();
  glPopMatrix(); 

  glPopMatrix(); 
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -8.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
    case 's': shoulder = (shoulder + 5) % 360; glutPostRedisplay(); break;
    case 'S': shoulder = (shoulder - 5) % 360; glutPostRedisplay(); break;
    case 'e': elbow = (elbow + 5) % 360; glutPostRedisplay(); break;
    case 'E': elbow = (elbow - 5) % 360; glutPostRedisplay(); break;
    case 'i': finger_index = (finger_index + 5) % 360; glutPostRedisplay(); break;
    case 'I': finger_index = (finger_index - 5) % 360; glutPostRedisplay(); break;
    case 'm': finger_middle = (finger_middle + 5) % 360; glutPostRedisplay(); break;
    case 'M': finger_middle = (finger_middle - 5) % 360; glutPostRedisplay(); break;
    case 'p': finger_thumb = (finger_thumb + 5) % 360; glutPostRedisplay(); break;
    case 'P': finger_thumb = (finger_thumb - 5) % 360; glutPostRedisplay(); break;
    case 'a': view_rot_y += 5.0f; glutPostRedisplay(); break;
    case 'd': view_rot_y -= 5.0f; glutPostRedisplay(); break;
    case 'w': view_rot_x += 5.0f; glutPostRedisplay(); break;
    case 27: exit(0); break;
    default: break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (700, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Braco Robotico com Garra Final");
  init ();
  glutDisplayFunc(display); 
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_braço_e_garra_3d">9.2. Braço e Garra 3D</h3>
<div class="paragraph">
<p>A versão 3D (<code>braco_garra_3d.c</code>) estende o conceito anterior. O programa permite a manipulação de um braço robótico 3D, incluindo a visualização da cena de diferentes ângulos de câmera.</p>
</div>
<div id="exa_braco_garra_3d" class="listingblock">
<div class="title">Listagem 16. braco_garra_3d.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

// Variáveis de estado para os ângulos das articulações
static int shoulder = 0, elbow = 0;
static int finger_index = 0, finger_middle = 0, finger_thumb = 0;
// NOVA variável para a rotação da base
static int base_rotation = 0;

// Variáveis de câmera
static GLfloat view_rot_x = 20.0f; 
static GLfloat view_rot_y = -30.0f;

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0); // Fundo preto
  glShadeModel (GL_SMOOTH); // Sombreamento suave (bom para modelos sólidos)

  // Habilita o teste de profundidade para renderização 3D correta
  glEnable(GL_DEPTH_TEST);
  // Habilita a remoção de faces "traseiras" para otimização
  glEnable(GL_CULL_FACE);
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  glPushMatrix(); 
  
  // Aplica as rotações da câmera
  glRotatef(view_rot_x, 1.0, 0.0, 0.0);
  glRotatef(view_rot_y, 0.0, 1.0, 0.0);
  
  // --- NOVO: Rotação da Base do Robô ---
  // Esta rotação afeta todo o braço que será desenhado a seguir.
  glRotatef((GLfloat) base_rotation, 0.0, 1.0, 0.0);

  // --- Braço ---
  glColor3f(1.0, 0.0, 0.0); // Cor Vermelha
  glTranslatef (-2.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.6, 1.0);
  glutSolidCube (1.0); // Trocado para SolidCube
  glPopMatrix();
   
  // --- Antebraço ---
  glColor3f(0.0, 1.0, 0.0); // Cor Verde
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.6, 1.0);
  glutSolidCube (1.0); // Trocado para SolidCube
  glPopMatrix();

  // --- Início da Garra ---
  glTranslatef(1.0, 0.0, 0.0);

  // --- Dedo Indicador ---
  glColor3f(0.0, 0.0, 1.0); // Cor Azul
  glPushMatrix();
      glTranslatef(0.0, 0.2, 0.0);
      glRotatef((GLfloat) finger_index, 0.0, 0.0, 1.0);
      glTranslatef(0.5, 0.0, 0.0);
      glPushMatrix();
          glScalef(1.0, 0.2, 0.2);
          glutSolidCube(1.0); // Trocado para SolidCube
      glPopMatrix();
  glPopMatrix();

  // --- Dedo Médio ---
  glColor3f(1.0, 1.0, 0.0); // Cor Amarela
  glPushMatrix();
      glTranslatef(0.0, -0.2, 0.0);
      glRotatef((GLfloat) finger_middle, 0.0, 0.0, 1.0);
      glTranslatef(0.5, 0.0, 0.0);
      glPushMatrix();
          glScalef(1.0, 0.2, 0.2);
          glutSolidCube(1.0); // Trocado para SolidCube
      glPopMatrix();
  glPopMatrix();

  // --- Dedo Polegar ---
  glColor3f(1.0, 0.0, 1.0); // Cor Magenta
  glPushMatrix();
      glTranslatef(0.0, 0.0, 0.5);
      glRotatef(-90.0, 0.0, 1.0, 0.0);
      glRotatef((GLfloat) finger_thumb, 0.0, 0.0, 1.0);
      glTranslatef(0.4, 0.0, 0.0);
      glPushMatrix();
          glScalef(0.8, 0.2, 0.2);
          glutSolidCube(1.0); // Trocado para SolidCube
      glPopMatrix();
  glPopMatrix(); 

  glPopMatrix(); 
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -8.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
    // Controles do braço
    case 's': shoulder = (shoulder + 5) % 360; glutPostRedisplay(); break;
    case 'S': shoulder = (shoulder - 5) % 360; glutPostRedisplay(); break;
    case 'e': elbow = (elbow + 5) % 360; glutPostRedisplay(); break;
    case 'E': elbow = (elbow - 5) % 360; glutPostRedisplay(); break;
    
    // Controles da garra
    case 'i': finger_index = (finger_index + 5) % 360; glutPostRedisplay(); break;
    case 'I': finger_index = (finger_index - 5) % 360; glutPostRedisplay(); break;
    case 'm': finger_middle = (finger_middle + 5) % 360; glutPostRedisplay(); break;
    case 'M': finger_middle = (finger_middle - 5) % 360; glutPostRedisplay(); break;
    case 'p': finger_thumb = (finger_thumb + 5) % 360; glutPostRedisplay(); break;
    case 'P': finger_thumb = (finger_thumb - 5) % 360; glutPostRedisplay(); break;
    
    // Controles de câmera
    case 'a': view_rot_y += 5.0f; glutPostRedisplay(); break;
    case 'd': view_rot_y -= 5.0f; glutPostRedisplay(); break;
    case 'w': view_rot_x += 5.0f; glutPostRedisplay(); break;
    
    // NOVOS controles da base
    case 'b': base_rotation = (base_rotation + 5) % 360; glutPostRedisplay(); break;
    case 'B': base_rotation = (base_rotation - 5) % 360; glutPostRedisplay(); break;
    
    // Controle de saída
    case 27: exit(0); break;
    default: break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (700, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Braco Robotico 3D Solido");
  init ();
  glutDisplayFunc(display); 
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Última atualização 2025-07-15 22:13:12 -0300
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>